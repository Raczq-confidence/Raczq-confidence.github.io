<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组去重以及排序</title>
      <link href="2020/122511745.html"/>
      <url>2020/122511745.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h2><p>在前端开发中经常会出现这样一个问题，怎么去除数组的重复项，接下来我将为大家介绍数组去重的几种方法</p><p>接下来的所有方法都会以下面的数组为例</p><pre class="line-numbers language-none"><code class="language-none">var arr = [1,2,1,3,2,3,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Set集合去重"><a href="#Set集合去重" class="headerlink" title="Set集合去重"></a>Set集合去重</h3><p>ES6中新增了一种数据类型<code>Set</code>（集合），Set中的元素只会<strong>出现一次</strong>，即 Set 中的元素是唯一的。</p><blockquote><p><strong>注意：<code>NaN</code>和<code>undefined</code>都可以被存储在Set 中， <code>NaN</code>之间被视为相同的值（NaN被认为是相同的，尽管 NaN !== NaN）</strong></p></blockquote><p>所以我们通过将数组转换为集合再转换回数组的方式来实现数组去重</p><pre class="line-numbers language-none"><code class="language-none">arr = [...new Set(arr)]console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe4ad9a3ffa7d37b3360794.png" alt="输出结果"></p><h3 id="对象去重"><a href="#对象去重" class="headerlink" title="对象去重"></a>对象去重</h3><p>因为向对象的已有属性进行添加时，属性的值会覆盖原来的值</p><pre class="line-numbers language-none"><code class="language-none">var obj = {}obj.a = 1obj.a = 2console.log(obj.a) //2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以我们可以通过遍历数组，向一个空对象添加属性，重复的属性会被覆盖掉</p><pre class="line-numbers language-none"><code class="language-none">var a = {}for( let i=0; i&lt;arr.length;i++ ) {let item = arr[i]a[item] = item}arr = []for(let i in a) {arr.push(a[i])}console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe4b0443ffa7d37b33a2b1e.png" alt="输出结果"></p><p>还可以通过这种方式来进行数组去重，将对象作为工具，直接在原数组上进行操作，本质上与上一种没有区别</p><pre class="line-numbers language-none"><code class="language-none">let a = {}for (let i = 0; i &lt; arr.length; i++) {let item = arr[i]if(typeof a[item] !== 'undefined' ){arr[i] = arr[arr.length-1]arr.length --i--continue}a[item] = item}console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe4b44c3ffa7d37b340d1ff.png" alt="输出结果"></p><p><strong>这种方法的好处就在于比遍历更加方便，更加迅速，但是缺点也可以从上图中看出，他改变了数组原来的顺序</strong></p><h3 id="排序去重"><a href="#排序去重" class="headerlink" title="排序去重"></a>排序去重</h3><p>我们还可以通过排序之后去除相等的相邻项来实现数组去重</p><pre class="line-numbers language-none"><code class="language-none">var arr = [1,2,5,3,2,3,4,1] //为了下文更好看出区别，这里决定采用这个数组function deleteRepeat (arr) {//对数组进行升序排序arr.sort()//对数组进行遍历for( let i = 0; i &lt; arr.length; i++ ) {//判断其不是第一项并且与前一项相等if( i != 0 &amp;&amp; arr[i] == arr[i-1] ) {//删除重复项arr.splice(i,1)}}return arr}console.log(deleteRepeat(arr))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe4b8a63ffa7d37b3475235.png" alt="输出结果"></p><p>可以看到数组排序成功，<strong>但是与上一个方法一样，同样会改变数组的顺序</strong></p><p>以上就是数组去重的几种常见方法</p><h2 id="2-数组排序"><a href="#2-数组排序" class="headerlink" title="2.数组排序"></a>2.数组排序</h2><p>数组排序的方法不需要多说，但是我们这里不打算使用sort等类似的排序方法，我们通过最基本的方法来实现，本文会介绍三种排序：冒泡排序，选择排序，快速排序。如果有朋友感兴趣可以去查找更多的排序方法，本文将不再过多赘述（本文在此只提出实现方法，具体思路请自行百度）</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-none"><code class="language-none">let arr = [12,8,15,16,1,24]for(let i=0; i &lt; arr.length-1; i++){for(let j=0; j &lt; arr.length-1-i; j++){if(arr[j]&gt;arr[j+1]) {let temp = arr[j]arr[j] = arr[j+1]arr[j+1] = temp}}}console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class="line-numbers language-none"><code class="language-none">let arr = [12,8,15,16,1,24]let A = []A.push(arr[0])for(let i=1; i&lt;arr.length; i++){for(let j=A.length-1; j&gt;=0; j--){if(arr[i]&gt;A[j]) {A.splice(j+1,0,arr[i])break}if(j === 0) {A.unshift(arr[i])}}}arr = Aconsole.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class="line-numbers language-none"><code class="language-none">//快速排序(相比冒泡与插入，性能最好)let arr = [12,8,15,16,1,24]function quik (array) {//判断数组是否只有一个元素if(array.length &lt;= 1){return array}//获取中间值let middleIndex = parseInt(array.length/2)let middle = array.splice(middleIndex,1)[0]//设置左右数组let arrLeft = [],arrRight = []for(let i=0; i&lt;array.length; i++){//当选取项大于中间值，将他添加到右数组；当选取项小于中间值，将他添加在左数组array[i]&gt;middle ? arrRight.push(array[i]) : arrLeft.push(array[i])}//递归调用函数对左右数组进行排序,之后对他们进行拼接return quik(arrLeft).concat(middle,quik(arrRight))}arr = quik(arr)console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS当中的深浅拷贝以及数组扁平化</title>
      <link href="2020/122431219.html"/>
      <url>2020/122431219.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-深浅拷贝"><a href="#1-深浅拷贝" class="headerlink" title="1.深浅拷贝"></a>1.深浅拷贝</h2><p><strong>因为JS的变量包含两种不同数据类型的值：基本类型和引用类型</strong></p><blockquote><p>1.JS当中的基本数据类型包含以下几种：</p><p>number，string，boolean，null，undefined，Symbol（ES6新增基本类型，之后会专门对他进行介绍）</p><p>2.JS当中的引用数据类型：</p><p>Object（Object，Array，Function）</p></blockquote><p>两种数据类型最根本的区别在于两种变量的存储方式是不同的</p><p><strong>JS存储变量的方式包含两种：栈内存（stack）和 堆内存（heap）</strong></p><blockquote><p>栈内存：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址</p><p>堆内存：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。</p></blockquote><p><img src="https://pic.downk.cc/item/5fe424583ffa7d37b35c55fb.png" alt="JS的存储方式"></p><p>因为这样的存储方式，所以JS种两种数据类型的数据传递方式也不一样</p><ul><li><p>基本数据类型采用的是值传递</p><pre class="line-numbers language-none"><code class="language-none">let a = 10; // 定义一个变量a并赋值为10let b = a;  // 将a的值10赋值给b (a、b都是基本类型，值传递)b++;  // b自加console.log(a, b) // 10, 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。</p><pre class="line-numbers language-none"><code class="language-none">let a = ['a', 'b', 'c']; // 定义一个数组a并赋值 let b = a;   // 数组是引用类型,采用地址传递，将a的地址赋值给bb.push('d'); // 给b数组增加一个'd'元素console.log(a) // ['a', 'b', 'c', 'd']console.log(b) // ['a', 'b', 'c', 'd']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>深浅拷贝是指复制对象的级别深浅，具体来讲就是：</p><ul><li>浅拷贝是指复制对象的时候，只对第一层键值对进行独立的复制，如果对象内还有对象，则只能复制嵌套对象的地址</li><li>深拷贝是指复制对象的时候完全的拷贝一份对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。其实只要递归下去，把那些属性的值仍然是对象的再次进入对象内部，进行复制即可。</li></ul><p>下面将为大家介绍深浅拷贝的几种实现方式</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><pre class="line-numbers language-none"><code class="language-none">let obj = {a : 10,b : [1,2,3],c : {x : 12},d : /^\d+$/ //正则表达式（也为引用数据类型）}let obj2 = {}//浅拷贝for(let key in obj){//判断属性是否为obj原型上的属性，是的话就结束循环if(!obj.hasOwnProperty(key)) break;obj2[key] = obj[key]}console.log(obj,obj2)console.log('obj == obj2',obj == obj2) //falseconsole.log('obj === obj2',obj === obj2) //falseconsole.log('obj.__proto__ == obj2.__proto__',obj.__proto__ == obj2.__proto__) //trueobj2.c.x = 1000console.log(obj.c.x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为浅拷贝的级别比较低，所以当我修改克隆后对象的属性（不为基本数据类型）时，原对象的属性也会被修改，原因就是引用数据类型会通过地址传递。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="1）JSON-parse和JSON-stringify"><a href="#1）JSON-parse和JSON-stringify" class="headerlink" title="1）JSON.parse和JSON.stringify"></a>1）<code>JSON.parse</code>和<code>JSON.stringify</code></h4><pre class="line-numbers language-none"><code class="language-none">let obj = {a : 10,b : [1,2,3],c : {x : 12} }let obj2 = JSON.parse(JSON.stringify(obj))console.log(obj2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种实现方法在项目中经常会使用到，<strong>缺点就是先转换为字符串再转换为对象，会开辟新的空间，并且当原对象中包含有函数（<code>Function</code>），日期（<code>Date</code>），正则表达式（<code>RegExp</code>）类型的属性时</strong>，就会出现下面例子出现的问题</p><pre class="line-numbers language-none"><code class="language-none">let obj = {a : 10,b : [1,2,3],c : {x : 12},d : /^\d+$/,e : function () {} }let obj2 = JSON.parse(JSON.stringify(obj))console.log(obj2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台输出的结果如下图所示</p><p><img src="https://pic.downk.cc/item/5fe42d0d3ffa7d37b362df61.png" alt="拷贝有误"></p><p>可以看出正则表达式类型的数据被转换为了{}，而函数类型的属性直接就消失不见了，所以我们可以采用下面的方式来进行深拷贝</p><h4 id="2）递归转换"><a href="#2）递归转换" class="headerlink" title="2）递归转换"></a>2）递归转换</h4><pre class="line-numbers language-none"><code class="language-none">let obj = {a : 10,b : [1,2,3],c : {x : 12},d : /^\d+$/,e : function () {} }function deepClone (obj) {//创建新的对象(通过这种方式创建的对象或者对象实例，他们的构造函数都是相同的)let newObj = new obj.constructor()//判断传入的实参是否为空if( obj === null ) return null//判断实参是否为对象(如果不为对象，则直接返回)if( typeof obj !== "object" ) return obj//判断传入实参是否为函数if( obj instanceof Function ){//创建返回值为新的Function实例return new Function(obj)}//判断传入实参是否为正则表达式if( obj instanceof RegExp ){//创建返回值为新的正则表达式实例return new RegExp(obj)}//判断传入实参是否为Dateif( obj instanceof Date ){//创建返回值为新的Function实例return new Date(obj)}//for( let key in obj ){//需要对数据进行过滤newObj[key] = deepClone(obj[key])}return newObj}let obj2 = deepClone(obj)console.log(obj,obj2)console.log('obj2 === obj',obj2 === obj) //falseconsole.log('obj2.c === obj.c',obj2.c === obj.c) //false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe431f83ffa7d37b3667cf6.png" alt="执行结果"></p><p>可以看到成功对obj对象进行了深拷贝</p><h2 id="2-数组扁平化"><a href="#2-数组扁平化" class="headerlink" title="2.数组扁平化"></a>2.数组扁平化</h2><p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。</p><p>举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：</p><pre class="line-numbers language-none"><code class="language-none">var arr = [1, [2, [3, 4]]]console.log(flatten(arr)) // [1, 2, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们将去尝试实现数组扁平化（下文数组扁平化的目标都将为下面的数组）</p><pre class="line-numbers language-none"><code class="language-none">var arr = [[1],[2],[3,4,[5,[6,[7]]]],8] //这是一个“四层”数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="flat方法实现"><a href="#flat方法实现" class="headerlink" title="flat方法实现"></a><code>flat</code>方法实现</h3><p>flat方法是ES6新提出的方法</p><p>flat方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。他挂载在Array.prototype上</p><p>他需要传入一个数字，指定要提取嵌套数组的结构深度，默认值为 1，当传入参数为 3 时</p><pre class="line-numbers language-none"><code class="language-none">arr = arr.flat(3)console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下图所示</p><p><img src="https://pic.downk.cc/item/5fe436103ffa7d37b36930e2.png" alt="当参数为3时"></p><p>当传入参数为 Infinity 时，Infinity 便是遍历无穷层数，将其转为“一维”数组</p><pre class="line-numbers language-none"><code class="language-none">arr = arr.flat(Infinity)console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下图所示</p><p><img src="https://pic.downk.cc/item/5fe436f63ffa7d37b369cfb4.png" alt="当参数为Infinity时"></p><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h3><p>将需要扁平化的数组先转换为字符串，再转换为数组，之后将每一项变为数字，实现方法如下</p><pre class="line-numbers language-none"><code class="language-none">arr = arr.toString().split(',').map( item =&gt; Number(item) )console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下图所示</p><p><img src="https://pic.downk.cc/item/5fe43b263ffa7d37b36cdd2f.png" alt="输出结果"></p><h3 id="利用正则表达式"><a href="#利用正则表达式" class="headerlink" title="利用正则表达式"></a>利用正则表达式</h3><pre class="line-numbers language-none"><code class="language-none">arr = JSON.stringify(arr).replace(/(\[|\])/g,'').split(',').map( item =&gt; Number(item) )console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果如下图所示</p><p><img src="https://pic.downk.cc/item/5fe43b6f3ffa7d37b36d0841.png" alt="输出结果"></p><h3 id="循环验证"><a href="#循环验证" class="headerlink" title="循环验证"></a>循环验证</h3><p>循环验证元素是否为数组(判断条件中的回调函数也可以写<code>Array.isArray(item))</code></p><pre class="line-numbers language-none"><code class="language-none">while( arr.some( item =&gt; item instanceof Array ) ){arr = [].concat(...arr)}console.log(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下图所示</p><p><img src="https://pic.downk.cc/item/5fe43b993ffa7d37b36d23e8.png" alt="输出结果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器搭建MySQL并远程连接</title>
      <link href="2020/12219273.html"/>
      <url>2020/12219273.html</url>
      
        <content type="html"><![CDATA[<p>感谢下面几篇博客的知识分享</p><ul><li><a href="https://www.jianshu.com/p/1dab9a4d0d5f">CentOS7 下 MySQL5.7的安装与配置</a></li><li><a href="https://blog.csdn.net/aa1215018028/article/details/90106425">MySQL5.7创建用户并授权，设置允许远程连接</a></li><li><a href="https://segmentfault.com/a/1190000022046000">记一次Navicat for MySQL 10060错误的解决过程</a></li></ul><p>本博客更多是根据我的具体情况来对上述三位进行总结</p><h2 id="1-CentOS7-下-MySQL5-7的安装与配置"><a href="#1-CentOS7-下-MySQL5-7的安装与配置" class="headerlink" title="1.CentOS7 下 MySQL5.7的安装与配置"></a>1.CentOS7 下 MySQL5.7的安装与配置</h2><p>本文的测试环境：</p><ul><li>CentOS 7.6.64</li><li>MySQL 5.7.32</li></ul><h3 id="安装MySQL源"><a href="#安装MySQL源" class="headerlink" title="安装MySQL源"></a>安装MySQL源</h3><p>安装MySQL源</p><pre class="line-numbers language-none"><code class="language-none"># 下载wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm# 安装 mysql 源yum localinstall mysql57-community-release-el7-11.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用下面的命令检查 MySQL源是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">yum repolist enabled | grep "mysql.*-community.*"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>使用 yum install 命令安装</p><pre class="line-numbers language-none"><code class="language-none">yum install -y mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p>在 CentOS 7 下，新的启动/关闭服务的命令是 <code>systemctl start|stop mysqld</code></p><pre class="line-numbers language-none"><code class="language-none">systemctl start mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 <code>systemctl status</code> 查看 MySQL 状态</p><pre class="line-numbers language-none"><code class="language-none">systemctl status mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe4054f3ffa7d37b345786f.jpg" alt="MySQL 启动状态"></p><h3 id="设置开机密码"><a href="#设置开机密码" class="headerlink" title="设置开机密码"></a>设置开机密码</h3><pre class="line-numbers language-none"><code class="language-none">systemctl enable mysqld# 重载所有修改过的配置文件systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="修改root本地账户密码"><a href="#修改root本地账户密码" class="headerlink" title="修改root本地账户密码"></a>修改root本地账户密码</h3><p>MySQL 安装完成之后，生成的默认密码在 <code>/var/log/mysqld.log</code> 文件中。使用 grep 命令找到日志中的密码。</p><pre class="line-numbers language-none"><code class="language-none">grep 'temporary password' /var/log/mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe404c33ffa7d37b34507ac.jpg" alt="查看临时密码"></p><p>临时密码就是localhost：后面的字段</p><p>接下来我们准备进入MYSQL数据库</p><pre class="line-numbers language-none"><code class="language-none">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来会需要输入密码，将上面看到的临时密码输入就可以进入MySQL数据库了</p><p>当shell的运行从shell&gt;变为mysql&gt;时，则进入数据库成功</p><p>首次通过初始密码登录后，需要使用以下命令修改密码</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED BY '此处为你想要设置的密码'; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改密码之后重新更新权限</p><pre class="line-numbers language-none"><code class="language-none">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意：mysql 5.7 默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 错误。查看 <a href="https://links.jianshu.com/go?to=https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html%23sysvar_validate_password_policy">MySQL官网密码详细策略</a></p></blockquote><p><strong>注意：</strong>建议将密码设置的复杂一点，之前我有一位朋友，账号和密码都是root，导致被黑客劫持，向他索要比特币（真会挑人，都是穷*），虽然数据库没什么重要的东西，但是之前项目搭建的数据库全部木大，所以在这里建议各位尽量设置的复杂一点</p><h3 id="设置默认编码为utf8"><a href="#设置默认编码为utf8" class="headerlink" title="设置默认编码为utf8"></a>设置默认编码为utf8</h3><p>mysql 安装后默认不支持中文，需要修改编码。<br>修改 <code>/etc/my.cnf</code> 配置文件，在相关节点（没有则自行添加）下添加编码配置，如下：</p><pre class="line-numbers language-none"><code class="language-none">[mysqld]character-set-server=utf8[client]default-character-set=utf8[mysql]default-character-set=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启mysql服务，查询编码。可以看到已经改过来了</p><pre class="line-numbers language-none"><code class="language-none">systemctl restart mysqldmysql -uroot -pshow variables like 'character%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.downk.cc/item/5fe405043ffa7d37b34538d9.jpg" alt="查看编码"></p><h2 id="2-远程连接"><a href="#2-远程连接" class="headerlink" title="2.远程连接"></a>2.远程连接</h2><h3 id="添加远程登录用户"><a href="#添加远程登录用户" class="headerlink" title="添加远程登录用户"></a>添加远程登录用户</h3><p>默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须<strong>添加一个允许远程连接的账户</strong>。或者<del>修改root为允许远程连接</del>（不推荐）</p><p>创建一个新用户</p><pre class="line-numbers language-none"><code class="language-none">CREATE USER 'username'@'host' IDENTIFIED BY 'password';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以<strong>从任意远程主机登录</strong>，可以使用通配符<code>%</code>，如果想让该用户从指定远程主机登录，可以输入对应主机的ip地址</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><p>例子：</p><ol><li><code>CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';</code></li><li><code>CREATE USER 'pig'@'192.168.1.101' IDENTIFIED BY '123456';</code></li><li><code>CREATE USER 'pig'@'%' IDENTIFIED BY '123456';</code></li><li><code>CREATE USER 'pig'@'%' IDENTIFIED BY '';</code></li><li><code>CREATE USER 'pig'@'%';</code></li></ol><h3 id="为新建用户授权"><a href="#为新建用户授权" class="headerlink" title="为新建用户授权"></a>为新建用户授权</h3><pre class="line-numbers language-none"><code class="language-none">GRANT privileges ON databasename.tablename TO 'username'@'host';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ul><li>privileges：用户的操作权限，如<code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>等，如果要授予所的权限则使用<code>ALL</code></li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<code>*</code>表示，如<code>*.*</code></li></ul><p>例子：</p><ol><li><code>GRANT SELECT, INSERT ON test.user TO 'pig'@'%';</code></li><li><code>GRANT ALL ON *.* TO 'pig'@'%';</code></li><li><code>GRANT ALL ON maindataplus.* TO 'pig'@'%';</code></li></ol><p><strong>注意：</strong></p><p>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令：</p><pre class="line-numbers language-none"><code class="language-none">GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开始远程连接"><a href="#开始远程连接" class="headerlink" title="开始远程连接"></a>开始远程连接</h3><p>接下来使用一些MySQL图形化界面来远程连接，我这里使用的是sqlyog</p><p>输入对应的主机ip地址，用户名，密码以及对应的端口</p><p><img src="https://pic.downk.cc/item/5fe340503ffa7d37b3d52f38.png" alt="sqlyog新连接"></p><p>如果直接成功请忽略下面的操作，如果连接失败出现了**ERROR: 2003 Can’t connect to MySQL server on ‘xxx.xx.xx.xx’**，可以通过下列方法逐步进行排查</p><h2 id="3-解决主机连接失败问题"><a href="#3-解决主机连接失败问题" class="headerlink" title="3.解决主机连接失败问题"></a>3.解决主机连接失败问题</h2><h3 id="检查网络"><a href="#检查网络" class="headerlink" title="检查网络"></a>检查网络</h3><p>先检查网络是否畅通，我才用的方法是Xshell访问远程主机，你也可以尝试使用<code>ping</code></p><h3 id="检查云服务器的安全组"><a href="#检查云服务器的安全组" class="headerlink" title="检查云服务器的安全组"></a>检查云服务器的安全组</h3><p>登录你服务器的对应控制台（阿里云就进入阿里云控制台，腾讯云就进入腾讯云控制台）</p><p>检查22，443，80，3306端口是否放通</p><h3 id="检查用户权限"><a href="#检查用户权限" class="headerlink" title="检查用户权限"></a>检查用户权限</h3><p>进入数据库</p><pre class="line-numbers language-none"><code class="language-none">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入密码进入数据库后，对于用户权限进行查询</p><pre class="line-numbers language-none"><code class="language-none">use mysqlselect host,user from user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果发现对应user的host有问题，则就是用户权限问题，如果为<code>%</code>或者正确的话，则继续向下排查</p><h3 id="检查CentOS防火墙"><a href="#检查CentOS防火墙" class="headerlink" title="检查CentOS防火墙"></a>检查CentOS防火墙</h3><p>这一步很容易被忽略，因为我当时就以为安全组已经设置好了，不必再检查CentOS的防火墙。其实检查防火墙是很有必要的，我们应该把3306端口放通，再重启防火墙，在Xshell中输入一下控制命令</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --permanent --zone=public --add-port=3306/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现success则设置成功</p><pre class="line-numbers language-none"><code class="language-none">firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现success则证明防火墙重启成功</p><p>再在sqlyog进行连接测试</p><p>出现下面界面证明远程连接成功</p><p><img src="https://pic.downk.cc/item/5fe345733ffa7d37b3dac430.png" alt="连接成功"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
